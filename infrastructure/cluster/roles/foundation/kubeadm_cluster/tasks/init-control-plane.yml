---
- name: Check if kubeadm has already been initialized
  stat:
    path: /etc/kubernetes/admin.conf
  register: kubeadm_init

- name: Initialize first control plane node
  when: not kubeadm_init.stat.exists
  block:
    - name: Complete containerd and cluster cleanup
      shell: |
        # Stop all services
        sudo systemctl stop kubelet containerd || true
        
        # Kill any remaining processes
        sudo fuser -k 10259/tcp 10257/tcp 2379/tcp 2380/tcp 6443/tcp || true
        
        # Complete containerd cleanup
        sudo rm -rf /var/lib/containerd/* || true
        sudo rm -rf /run/containerd/* || true
        
        # Clean up kubernetes directories
        sudo rm -rf /var/lib/etcd/* || true
        sudo rm -rf /etc/kubernetes/manifests/* || true
        sudo rm -rf /etc/kubernetes/pki || true
        sudo rm -rf /var/lib/kubelet/* || true
        
        # Restart containerd with fresh state
        sudo systemctl start containerd
        
        # Wait for containerd to be ready
        sleep 10
        
        # Verify containerd is working
        sudo crictl version || true
        
        # Start kubelet
        sudo systemctl start kubelet
        
        # Wait for services to stabilize
        sleep 5
      become: true
      ignore_errors: true

    - name: Create audit policy file
      copy:
        dest: "{{ audit_policy_file }}"
        content: |
          apiVersion: audit.k8s.io/v1
          kind: Policy
          rules:
          # Log all requests at the metadata level
          - level: Metadata
            resources:
            - group: ""
              resources: ["*"]
        mode: '0644'
      become: true
      when: audit_log_enabled

    - name: Create audit log directory
      file:
        path: /var/log/kubernetes
        state: directory
        mode: '0755'
      become: true
      when: audit_log_enabled

    - name: Create kubeadm configuration
      template:
        src: kubeadm-config.yaml.j2
        dest: /tmp/kubeadm-config.yaml
      become: true

    - name: Initialize Kubernetes cluster
      command: kubeadm init --config /tmp/kubeadm-config.yaml
      become: true
      register: kubeadm_init_output

    - name: Create .kube directory for user
      file:
        path: "{{ ansible_env.HOME }}/.kube"
        state: directory
        mode: '0755'

    - name: Debug - Check initial admin.conf certificate
      shell: |
        grep client-certificate-data /etc/kubernetes/admin.conf | cut -d: -f2 | tr -d ' ' | base64 -d | openssl x509 -noout -subject
      register: initial_cert
      become: true
      ignore_errors: true

    - name: Fix admin.conf with correct RBAC group
      shell: |
        kubeadm kubeconfig user --client-name=kubernetes-admin --org=system:masters > /etc/kubernetes/admin.conf.fixed
        mv /etc/kubernetes/admin.conf.fixed /etc/kubernetes/admin.conf
      become: true

    - name: Debug - Check fixed admin.conf certificate
      shell: |
        grep client-certificate-data /etc/kubernetes/admin.conf | cut -d: -f2 | tr -d ' ' | base64 -d | openssl x509 -noout -subject
      register: fixed_cert
      become: true

    - name: Debug - Show certificate subjects
      debug:
        msg: |
          Initial cert: {{ initial_cert.stdout | default('Failed to get initial cert') }}
          Fixed cert: {{ fixed_cert.stdout }}

    - name: Copy admin.conf to user's kube config
      copy:
        src: /etc/kubernetes/admin.conf
        dest: "{{ ansible_env.HOME }}/.kube/config"
        remote_src: yes
        owner: "{{ ansible_user }}"
        mode: '0600'
      become: true

    - name: Generate fresh join command
      command: kubeadm token create --print-join-command
      register: fresh_join_command
      become: true

    - name: Create join command file
      copy:
        content: "{{ fresh_join_command.stdout }}"
        dest: /tmp/kubeadm_join_command.sh
        mode: '0755'
      become: true

    - name: Debug - Test kubectl directly
      shell: |
        export KUBECONFIG=/etc/kubernetes/admin.conf
        kubectl version --short --insecure-skip-tls-verify 2>&1 || true
      register: kubectl_test
      become: true
      ignore_errors: true

    - name: Debug - Show kubectl test output
      debug:
        msg: |
          Kubectl test stdout: {{ kubectl_test.stdout }}
          Kubectl test stderr: {{ kubectl_test.stderr }}

    - name: Wait for API server to be accessible
      shell: |
        export KUBECONFIG=/etc/kubernetes/admin.conf
        kubectl get --raw /healthz --insecure-skip-tls-verify 2>/dev/null || echo "Failed"
      register: api_ready_check
      until: api_ready_check.stdout == "ok"
      retries: 15
      delay: 10
      changed_when: false
      become: true

    - name: Upload certificates for control plane join
      command: kubeadm init phase upload-certs --upload-certs
      register: cert_key_output
      become: true

- name: Check node status (informational)
  shell: |
    export KUBECONFIG=/etc/kubernetes/admin.conf
    kubectl get nodes {{ inventory_hostname }} -o jsonpath='{.status.conditions[?(@.type=="Ready")].status}' 2>/dev/null || echo "NotReady"
  register: node_status_check
  changed_when: false
  become: true

- name: Display node status
  debug:
    msg: "Node {{ inventory_hostname }} status: {{ node_status_check.stdout }} (Note: NotReady is expected until CNI is installed)"